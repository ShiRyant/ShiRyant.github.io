[{"id":"d843ced03f40ac612213952de4b63ad2","title":"二分查找","content":"本文参考了CSDN上的相关文章，原文链接见下【二分查找】详细图解_Charon_cc的博客-CSDN博客-二分查找)\n概述要使用二分查找，需要满足:::\n\n要查找的内容在逻辑上是有序的(比如升序、降序)\n只能查找一个元素:::\n\n","slug":"artical3","date":"2023-01-24T07:08:42.505Z","categories_index":"","tags_index":"算法,二分查找","author_index":"莳雨"},{"id":"006076f8418c8c0b510fc49a5533190d","title":"寻找数组中和为定值的两个数","content":"问题描述输入一个整数数组和一个整数，在数组中查找一对数，满足他们的和正好是输入的那个整数\n方法：排序夹逼法（双指针扫描）若原数组无序，考虑先用sort对数组排序，但是如果题目要求输出数组下标，此方法就不太适用了（排序会打乱原数组的下标，输出的时候可能就需要多考虑一些东西了）数组有序之后，用两个指针分别指向数组头部和尾部，令begin&#x3D;0，end&#x3D;nums.end()-1，判断nums[begin]+nums[end]是否等于目标数target，若nums[begin]+nums[end] &gt; target，保持begin不变，让end–；反之，保持end不变，让begin++，while循环条件为begin &lt; end\n示例代码（保证数组升序排列）#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tprintf(&quot;请输入目标数\\n&quot;);\n\tint target; cin &gt;&gt; target;\n\tprintf(&quot;请输入数组元素个数\\n&quot;);\n\tint n; cin &gt;&gt; n;\n\tint* nums &#x3D; new int[n];\n\tprintf(&quot;请输入数组各元素\\n&quot;);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tcin &gt;&gt; nums[i];\n\tint begin &#x3D; 0, end &#x3D; n - 1;\n\twhile (begin &lt; end)\n\t&#123;\n\t\tif (nums[begin] + nums[end] &#x3D;&#x3D; target)\n\t\t&#123;\n\t\t\tprintf(&quot;和为%d的两元素为%d,%d\\n&quot;, target, nums[begin], nums[end]);\n\t\t\tprintf(&quot;它们是nums[%d]和nums[%d]\\n&quot;, begin, end);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse if (nums[begin] + nums[end] &lt; target)\n\t\t\tbegin++;\n\t\telse\n\t\t\tend--;\n\t&#125;\n\tdelete[] nums;\n\treturn 0;\n&#125;\n\n感谢阅读！！ヾ(•ω•&#96;)o\n","slug":"artical2","date":"2023-01-24T06:02:13.787Z","categories_index":"","tags_index":"算法","author_index":"莳雨"},{"id":"bcea4f6293f54fdbb1d383135d606a9c","title":"补题报告(1.16-1.23)","content":"本周完成的题目(共12题)，链接见下1001-随机序列1002-记数问题1003-约瑟夫环1004-校门外的树1005-比较月亮大小1006-求距离1007-数列下标1011-序列中整数去重1012-有序序列插入一个整数1013-打印质数表1015-有序序列合并1029-明明的随机数\n本周完成的比赛：牛客寒假训练赛1、2、3训练赛1A题题目链接：A-World Final? World Cup! (I)思路：枚举1-10场的情况，确定第i场能否决定胜负检查方式：剩余的 10-i 场里，假设最后A最高A1分、最低A2分，B最高B1分、 最低B2分，则可以确定胜负当且仅当：(A1-B2)(B1-A2)&lt;0代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint T;\nchar Arr[12];\nint main()\n&#123;\n\tcin &gt;&gt; T;\n\twhile (T--)\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t\t\tcin &gt;&gt; Arr[i];\n\t\tint A &#x3D; 0, B &#x3D; 0, flag &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t\t&#123;\n\t\t\tif (Arr[i] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tif (i % 2) A++;\n\t\t\t\telse B++;\n\t\t\t&#125;\n\t\t\tint A_best &#x3D; (10 - i) &#x2F; 2, B_best &#x3D; (11 - i) &#x2F; 2;\n\t\t\tif ((A + A_best - B) * (A - (B + B_best)) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t\t\t\tflag &#x3D; 0;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (flag) cout &lt;&lt; -1 &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nC题题目链接：C-现在是，学术时间 (I)思路：本题有坑，直接按每名教授分配1篇论文即为最高情况，因为H指数的定义决定它最大不会超过论文数，总论文数减去引用量为0的论文数即可代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint T,n,a[100005]\nint main()\n&#123;\n\tcin&gt;&gt;T;\n\twhile(T--)\n\t&#123;\n\t\tcin&gt;&gt;n;\n\t\tint ret&#x3D;0;\n\t\tfor(int i&#x3D;0;i&lt;n;i++)\n\t\t&#123;\n\t\t\tcin&gt;&gt;a[i];\n\t\t\tif(a[i]) ret++;\n\t\t&#125;\n\t\tcout&lt;&lt;ret&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n&#125;\n\nD题题目链接：D-现在是，学术时间 (II)思路：此题有4种情况，分类讨论即可首先另一个矩形顶点一定是ABCD之一，考虑P点坐标的四种情况，即下图四个区域• 区域1：枚举A、B、C、D作为另一顶点 的四种情况，取最大IOU；• 区域3：取A作为另一顶点；• 区域2：枚举A、B作为另一顶点的两种 情况，选较大的IOU；• 区域4：枚举A、D作为另一顶点的两种 情况，选较大的IOU；比赛时没有考虑这么多，所以没想到合适的解法代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nlong long x, y, xp, yp;\nint main()\n&#123;\n    int T; cin &gt;&gt; T;\n    while (T--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; xp &gt;&gt; yp;\n        double res &#x3D; 0;\n        if (xp &lt;&#x3D; x &amp;&amp; yp &lt;&#x3D; y)\n        &#123;\n            res &#x3D; max(xp * yp &#x2F; (double)(x * y), xp * (y - yp) &#x2F; (double)(x * y));\n            res &#x3D; max(res, (x - xp) * yp &#x2F; (double)(x * y));\n            res &#x3D; max(res, (x - xp) * (y - yp) &#x2F; (double)(x * y));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        if (xp &lt;&#x3D; x)\n        &#123;\n            res &#x3D; max(xp * y &#x2F; (double)(x * y + xp * (yp - y)),\n                (x - xp) * y &#x2F; (double)(x * y + (x - xp) * (yp - y)));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        if (yp &lt;&#x3D; y)\n        &#123;\n            res &#x3D; max(x * yp &#x2F; (double)(x * y + yp * (xp - x)),\n                x * (y - yp) &#x2F; (double)(x * y + (y - yp) * (xp - x)));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        res &#x3D; x * y &#x2F; (double)(xp * yp);\n        printf(&quot;%.10f\\n&quot;, res);\n    &#125;\n    return 0;\n&#125;\nH题题目链接：H-本题主要考察了DFS思路：拼图总造价是$10n^2$；拼图总造价 &#x3D; 给出拼图的造价 + 缺失拼图的造价，所以一减就行代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tint T; cin &gt;&gt; T;\n\twhile (T--)\n\t&#123;\n\t\tint n; cin &gt;&gt; n;\n\t\tint t &#x3D; n * n - 1;\n\t\tint m &#x3D; 0;\n\t\twhile (t--)\n\t\t&#123;\n\t\t\tstring a; cin &gt;&gt; a;\n\t\t\tint i, sum &#x3D; 10;\n\t\t\tfor (i &#x3D; 0; i &lt; 4; i++)\n\t\t\t&#123;\n\t\t\t\tif (a[i] &#x3D;&#x3D; &#39;1&#39;) sum--;\n\t\t\t\telse if (a[i] &#x3D;&#x3D; &#39;2&#39;) sum++;\n\t\t\t&#125;\n\t\t\tm +&#x3D; sum;\n\t\t&#125;\n\t\tcout &lt;&lt; 10 * n * n - m &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nK题题目链接：K-本题主要考察了dp思路：类似1001001001……11111这样的串（也就是密的部分全是1，松的部分一个1占多数的区间都没有）比较优，枚举i，在字符串前i个填上形如100100……的前缀，后面全填1，判断该串1的个数是否满足条件，满足则和当前答案取min即可代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int a[1010], ans &#x3D; 0;\n    memset(a, 0, sizeof(a));\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i +&#x3D; 3)\n    &#123;\n        a[i] &#x3D; 1;\n        m--;\n    &#125;\n    &#x2F;&#x2F; 先满足排列前面为100100......\n    for (int i &#x3D; n; m &gt; 0; i--)\n    &#123;\n        if (a[i]&#x3D;&#x3D;0)\n        &#123;\n            a[i] &#x3D; 1;\n            m--;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 再保证排列后面为111111111...\n    for (int i &#x3D; 1; i &lt;&#x3D; n - 2; i++)\n    &#123;\n        if (a[i] + a[i + 1] + a[i + 2] &gt;&#x3D; 2)\n            ans++;\n    &#125;\n    &#x2F;&#x2F; 判断各个区间是否为坏区间\n    cout &lt;&lt; ans;\n    return 0;\n&#125;\n训练赛2B题题目链接：B-Tokitsukaze and a+b&#x3D;n (medium)思路： a 的取值范围 [L1, R1]，满足 a + b &#x3D; n 的 b 的范围是 [n − L1, n − R1]，但是合法的 b 的范围是 [L2, R2] ，区间 [n − L1, n − R1] 与 [L2, R2] 取交后的区间长度即为答案。公式：两个区间 [a, b]，[c, d] 取交的区间长度为max(0, min(d, b) − max(a, c) + 1)代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main() &#123;\n    long long t, n, l1, l2, r1, r2, res;\n    cin&gt;&gt;t;\n    while (t--) \n    &#123; \n        cin&gt;&gt;n;\n        cin&gt;&gt;l1&gt;&gt;r1;\n        cin&gt;&gt;l2&gt;&gt;r2;\n        if(l1+l2&gt;n||r1+r2&lt;n)\n            cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;\n        else\n            cout&lt;&lt;abs(max(l1,n-r2)-min(n-l2,r1))+1&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\nD题题目链接：D-Tokitsukaze and Energy Tree思路：经典结论，两个向量内部允许任意重排，则点积最大方法为都升序排列可以发现当第 i 个能量球放置在节点 x 时，它的贡献为：节点 1 到节点 x 的高度 hx * 能量球的能量 vi ，求出高度 h 后，分别对高度 h 和 能量 v 排序，之后大的乘大的，再全部加起来即可代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n&#123;\n\tll n, i, f, sum &#x3D; 0; cin &gt;&gt; n;\n\tll a[300000] &#x3D; &#123; 0 &#125;, b[300000] &#x3D; &#123; 0 &#125;;\n\ta[1] &#x3D; 1;\n\tfor (i &#x3D; 2; i &lt;&#x3D; n; i++) \n\t&#123;\n\t\tcin &gt;&gt; f;\n\t\ta[i] &#x3D; a[f] + 1;\n\t&#125;\n\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tcin &gt;&gt; b[i];\n\tsort(a + 1, a + 1 + n);\n\tsort(b + 1, b + 1 + n);\n\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\tsum &#x3D; sum + a[i] * b[i];\n\tcout &lt;&lt; sum;\n\treturn 0;\n&#125;\nH题题目链接：H-Tokitsukaze and K-Sequence思路：每种数字的贡献可以分开计算。按照每种数字出现的次数进行讨论假设数字$x$出现的次数为 $cnt_x$， 如果$cnt_x\\le k$，可以贪心地将每个$x$都分到某个子序列中，使得每个子序列要么只包含 1 个$x$，要么不包含$x$，所以此时数字$x$的贡献为$cnt_x$ ，如果$cnt_x &gt; k$，我们按照上面的方法分配完$k$个$x$，多出来的$x$必须分配到某个子序列中，导致 那个子序列中，数字$x$没有贡献。所以此时数字$x$的贡献为$k-1$，答案就是每种数字的贡献求和求$k &#x3D; 1···n$的答案，对 $cnt$ 从小到大排序，枚举$k &#x3D; 1···n$，答案为 $cnt_x\\le k$的$cnt_x$求和，加上$cnt_x &gt; k$的 $cnt_x$ 的个数乘上$(k-1)$代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a[100005];\nint main() \n&#123;\n\tint t; cin &gt;&gt; t;\n\twhile (t--) \n\t&#123;\n\t\tint n; cin &gt;&gt; n;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tcin &gt;&gt; a[i];\n\t\tsort(a, a + n);\n\t\tint cnt[100005], b &#x3D; 1, c &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t&#123;\n\t\t\tif (a[i] &#x3D;&#x3D; a[i - 1]) b++;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tcnt[c++] &#x3D; b;\n\t\t\t\tb &#x3D; 1;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcnt[c++] &#x3D; b;\n\t\tsort(cnt, cnt + c);\n\t\tint k &#x3D; 0, ans1 &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\twhile (k &lt; c)\n\t\t\t&#123;\n\t\t\t\tif (cnt[k] &lt;&#x3D; i)\n\t\t\t\t&#123;\n\t\t\t\t\tans1 +&#x3D; cnt[k];\n\t\t\t\t\tk++;\n\t\t\t\t&#125;\n\t\t\t\telse break;\n\t\t\t&#125;\n\t\t\tint ans2 &#x3D; (c - k) * (i - 1);\n\t\t\tcout &lt;&lt; ans1 + ans2 &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\nJ题题目链接：J-Tokitsukaze and Sum of MxAb思路：先对题目给的式子分情况讨论，再化简，可得$max(|a_i-a_j|,|a_i+a_j|)&#x3D;|a_i|+|a_j|$，则题目要求的式子可化为$2·n·\\textstyle\\sum_{i&#x3D;1}^n|a_i|$，据此求解即可代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint t,a[100005];\nint mxab(int x,int y)\n&#123;\n    return max(abs(x-y),abs(x+y));\n&#125;\nint main ()\n&#123;\n    cin&gt;&gt;t;\n    while(t--)\n    &#123;\n        int n; cin&gt;&gt;n;\n        long long sum&#x3D;0;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            cin&gt;&gt;a[i];\n            sum+&#x3D;abs(a[i]);\n        &#125;\n        cout&lt;&lt;sum*n*2&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n训练赛3B题题目链接：B-勉强拼凑的记忆思路：这道题可以试着推演找规律，也可以二分假设答案为ans，ans必定满足$\\lceil\\frac{n}{2}\\rceil\\le ans\\le n$(取$\\lceil\\frac{n}{2}\\rceil$块时一定有解)画图得到最优情况下ans满足$ans\\le\\frac{n+2\\lceil\\frac{n}{2}\\rceil}{3}$代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n&#123;\n\tint t; cin &gt;&gt; t;\n\twhile(t--)\n\t&#123;\n\t\tll x; cin &gt;&gt; x;\n\t\tif (x &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tcout &lt;&lt; 1 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tif (x &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tcout &lt;&lt; -1 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tll ans &#x3D; (x + 2 * ((x + 1) &#x2F; 2) &#x2F; 3);\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nC题题目链接：C-忽远忽近的距离思路：构造题，原则：找到一个既有一般性，又有可行性的构造原则，本题按照n模4的余数来进行分类(比赛时自己只考虑到了3类，没有考虑n模4余3的场合)，按n分为n&#x3D;4k,n&#x3D;4k+5,n&#x3D;4k+6,n&#x3D;4k+5+6四种情况，注意n&#x3D;7是无解的(当时在这里误判了，导致最后只做了3种情况)，每种情况把数字按数量分成4个和5个这两类小块，参考样例格式输出即可代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint cnt&#x3D;0,a[100005];\nvoid f0(int n)\n&#123;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n    &#123;\n        if(i%4&#x3D;&#x3D;1) a[i]&#x3D;3+cnt*4;\n        if(i%4&#x3D;&#x3D;2) a[i]&#x3D;4+cnt*4;\n        if(i%4&#x3D;&#x3D;3) a[i]&#x3D;1+cnt*4;\n        if(i%4&#x3D;&#x3D;0)\n        &#123;\n            a[i]&#x3D;2+cnt*4;\n            cnt++;\n        &#125;\n    &#125;\n&#125;\nvoid f1(int n)\n&#123;\n    f0(n-5);\n    a[n-4]&#x3D;4+cnt*4;\n    a[n-3]&#x3D;5+cnt*4;\n    a[n-2]&#x3D;1+cnt*4;\n    a[n-1]&#x3D;2+cnt*4;\n    a[n]&#x3D;3+cnt*4;\n&#125;\nvoid f2(int n)\n&#123;\n    f0(n-6);\n    a[n-5]&#x3D;4+cnt*4;\n    a[n-4]&#x3D;5+cnt*4;\n    a[n-3]&#x3D;6+cnt*4;\n    a[n-2]&#x3D;1+cnt*4;\n    a[n-1]&#x3D;2+cnt*4;\n    a[n]&#x3D;3+cnt*4;\n&#125;\nvoid f3(int n)\n&#123;\n    f0(n-11);\n    a[n-10]&#x3D;4+cnt*4;\n    a[n-9]&#x3D;5+cnt*4;\n    a[n-8]&#x3D;1+cnt*4;\n    a[n-7]&#x3D;2+cnt*4;\n    a[n-6]&#x3D;3+cnt*4;\n    cnt++;\n    a[n-5]&#x3D;4+cnt*4+1;\n    a[n-4]&#x3D;5+cnt*4+1;\n    a[n-3]&#x3D;6+cnt*4+1;\n    a[n-2]&#x3D;1+cnt*4+1;\n    a[n-1]&#x3D;2+cnt*4+1;\n    a[n]&#x3D;3+cnt*4+1;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    if(n&lt;4||n&#x3D;&#x3D;7) cout&lt;&lt;&quot;-1&quot;;\n    else\n    &#123;\n        if(n%4&#x3D;&#x3D;0) f0(n);\n        if(n%4&#x3D;&#x3D;1) f1(n);\n        if(n%4&#x3D;&#x3D;2) f2(n);\n        if(n%4&#x3D;&#x3D;3) f3(n);\n         for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n         &#123;\n            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nE题题目链接：E-公平守望的灯塔思路：这题用向量就行，先设AB中点为M，要求的点为C，易求出M点坐标，然后利用高中数学知识求出$\\overrightarrow{MC}$，这样就能求出C点坐标了代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nll xa, ya, xb, yb, xm, ym;\nint main() \n&#123;\n\tcin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n\txa *&#x3D; 2; ya *&#x3D; 2; xb *&#x3D; 2; yb *&#x3D; 2;\n\txm &#x3D; (xa + xb) &#x2F; 2ll;\n\tym &#x3D; (ya + yb) &#x2F; 2ll;\n\tll dx &#x3D; xm - xa, dy &#x3D; ym - ya;\n\tif ((xm + dy) % 2ll &#x3D;&#x3D; 0 &amp;&amp; (ym - dx) % 2ll &#x3D;&#x3D; 0) \n\t\tprintf(&quot;%lld %lld\\n&quot;, (xm + dy) &#x2F; 2ll, (ym - dx) &#x2F; 2ll);\n\telse if ((xm - dy) % 2ll &#x3D;&#x3D; 0 &amp;&amp; (ym + dx) % 2ll &#x3D;&#x3D; 0) \n\t\tprintf(&quot;%lld %lld\\n&quot;, (xm - dy) &#x2F; 2ll, (ym + dx) &#x2F; 2ll);\n\telse \n\t\tputs(&quot;No Answer!&quot;);\n\treturn 0;\n&#125;","slug":"artical1","date":"2023-01-23T13:31:23.057Z","categories_index":"","tags_index":"算法","author_index":"莳雨"}]