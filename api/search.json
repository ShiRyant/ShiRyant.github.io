[{"id":"8cf32e9d14bee8e65785fa5e53e55961","title":"upper_bound与lower_bound的用法","content":"在牛客做题的时候偶然了解到的两个函数，发现还挺方便的，这边记录一下原文链接关于lower_bound( )和upper_bound( )的常见用法\n头文件#include &lt;algorithm&gt;\n函数形式及用法在从小到大的排序数组中lower_bound(begin,end,num)从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标upper_bound(begin,end,num)从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标\n在从大到小的排序数组中lower_bound(begin,end,num,greater&lt;type&gt;())从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标upper_bound(begin,end,num,greater&lt;type&gt;())从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标此外，这两个函数也能通过自定义函数的方式改变查找规则（类似sort()内的cmp）\n\n\n\n\n\n\n提示\n由于 upper_bound() 底层实现采用的是二分查找的方式，因此该函数仅适用于“已排好序”的序列。注意，这里所说的“已排好序”，并不要求数据完全按照某个排序规则进行升序或降序排序，而仅仅要求[first, last) 区域内所有令 element&lt;val（或者 comp(val, element）成立的元素都位于不成立元素的前面\n\n","slug":"artical5","date":"2023-01-28T10:51:14.741Z","categories_index":"算法","tags_index":"算法","author_index":"莳雨"},{"id":"5ba9516e9c52d7566ec1c7c5d2db970e","title":"前缀和算法","content":"前缀和算法样题题目描述\n\n\n\n\n\n\n\n\n\n输入一个长度为n的整数序列  接下来再输入m个询问，每个询问输入一对l, r  对于每个询问，输出原序列中从第l个数到第r个数的和\n输入格式\n\n\n\n\n\n\n\n\n\n第一行包含两个整数n和m第二行包含n个整数，表示整数数列接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。\n输出格式\n\n\n\n\n\n\n\n\n\n共m行，每行输出一个询问的结果\n数据范围\n\n\n\n\n\n\n\n\n\n1≤l≤r≤n,1≤n,m≤1e5,−1e5≤数列中元素的值≤1e5\n输入样例\n\n\n\n\n\n\n\n\n\n5 32 1 3 6 41 21 32 4\n输出样例\n\n\n\n\n\n\n\n\n\n3610\n代码实现\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a[100005];\nint main()&#123;\n    int N,M; cin&gt;&gt;N&gt;&gt;M;\n    for(int i&#x3D;1;i&lt;&#x3D;N;i++)\n        cin&gt;&gt;a[i];\n    for(int i&#x3D;1;i&lt;&#x3D;N;i++)\n        a[i]+&#x3D;a[i-1];\n    while(M--)&#123;\n        int l,r; cin&gt;&gt;l&gt;&gt;r;\n        cout&lt;&lt;a[r]-a[l-1]&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n什么是前缀和定义两个数组a[n]，s[n]，其中用a[n]表示原数组，s[n]表示a[n]的前缀和，有s[n]=a[n]+a[n-1]+a[n-2]+···+a[2]+a[1]即前缀和s[n]为原数列第1个到第n个元素的和\n前缀和的优势对于上面区间求和的样题，相较于用双循环(时间复杂度n(n*m))，前缀和能节省非常多的时间(时间复杂度n(n+m))，当数据过大时，前者在运算时可能会超时，而后者不会\n用前缀和算法解决区间求和问题要求的是区间 (L, R) 内的和，即求a[L]+a[L+1]+···+a[R]只需令s[L-1]&#x3D;a[L-1]+a[L-2]+···+a[2]+a[1]s[R]&#x3D;a[R]+a[R-1]+a[R-2]+···+a[2]+a[1]用 s[R] 减去 s[L-1]，就得到了区间[L, R]的和**ˋ( ° ▽、° ) **\n","slug":"artical4","date":"2023-01-25T05:29:57.240Z","categories_index":"算法","tags_index":"算法","author_index":"莳雨"},{"id":"d843ced03f40ac612213952de4b63ad2","title":"二分查找","content":"本文参考了CSDN上的相关文章，原文链接见下(原文写的非常非常好，强烈建议去看看！)【二分查找】详细图解_Charon_cc的博客-CSDN博客-二分查找)\n概述要使用二分查找，需要满足：1.要查找的内容在逻辑上是有序的(比如升序、降序)2.只能查找一个元素在满足这两个前提之后，要求我们查找数组中的指定元素时就可以使用二分查找了，这种方法的效率比较高\n\n\n\n\n\n\n提示\n在二分查找中，目标元素的查找区间的定义十分重要，不同的区间的定义写法不一样，大体有两种写法，注意辨析哦\n\n1.左闭右闭 [left , right]2.左闭右开 [left , right)\n例子先看一道leetcode上面的题目704. 二分查找 - 力扣（Leetcode）输入描述\n\n\n\n\n\n\n\n\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1\n样例1\n\n\n\n\n\n\n\n\n\n输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9  输出: 4  解释: 9 出现在 nums 中并且下标为 4\n样例2\n\n\n\n\n\n\n\n\n\n输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2  输出: -1  解释: 2 不存在 nums 中因此返回 -1\n提示\n\n\n\n\n\n\n\n\n\n你可以假设 nums 中的所有元素是不重复的。   n 将在 [1, 10000]之间。   nums 的每个元素都将在 [-9999, 9999]之间。\n代码(写法1)\nint search(int nums[], int size, int target)&#123;\n    int left &#x3D; 0;\n    int right &#x3D; size - 1;\n    while (left &lt;&#x3D; right) &#123;\t\n        int middle &#x3D; left + ((right - left) &#x2F; 2);\n        if (nums[middle] &gt; target) \n            right &#x3D; middle - 1;\n\t    else if (nums[middle] &lt; target) \n            left &#x3D; middle + 1;\n        else \n            return middle;\n    &#125;\n    return -1;\n&#125;\n代码(写法2)\nint search(int nums[], int size, int target)&#123;\n\tint left &#x3D; 0;\n\tint right &#x3D; size;\n\twhile (left &lt; right) &#123;\n\t\tint middle &#x3D; left + ((right - left) &#x2F; 2);\n\t\tif (nums[middle] &gt; target) &#123;\n\t\t\tright &#x3D; middle;\n\t\t&#125; else if (nums[middle] &lt; target) &#123;\n\t\t\tleft &#x3D; middle + 1;\n\t\t&#125; else &#123;\n\t\t\treturn middle;\n\t\t&#125;\n\t&#125; \n\treturn -1;\n&#125;\n基本思想首先定义left和right，确定查找区间，定义middle＝(left+right)/2，判断nums[middle]?=target，若相等，直接return middle否则\n\n如果nums[middle] &gt; target，说明目标数在middle左边，因此下次查找的区间就变成了[left, middle-1]，令right=middle-1，继续查找\n如果nums[middle] &lt; target，说明目标数在middle右边，因此下次查找的区间就变成了[middle+1, right]，令left=middle+1，继续查找\n直到nums[middle]=target或者left&gt;right，结束查找\n\n写法1：左闭右闭[left , right]\n此时循环条件为left&lt;=right，因为当(left == right)时，结果是有意义的\nif(nums[middle] &gt; target) ，right要赋值为middle-1， 这时候nums[middle]!=target ，所以需要把这个middle位置上面的数字丢弃，接下来需要查找的范围是[left, middle - 1]，直到查找结束\n详细过程图解参考上面贴出的原文链接即可，此处不再赘述\n\n写法2：左闭右开 [left , right)\n循环条件为left &lt; right\nif (nums[middle] &gt; target)，right = middle，这时候 nums[middle]&gt;target，不符合条件，不能取到middle，并且区间的定义是[left, right)，刚好区间上的定义就取不到right, 所以right赋值为middle即可，接下来就在[left, middle)上面继续查找即可\n详细过程同样参见原文\n\n\n\n\n\n\n\n\n注意\n此方法需为right赋初值为数组长度！因为右边是开区间，并且这种写法只有当nums[middle] &gt; target时和写法一不一样，当nums[middle] &lt; target时，仍然为left=middle+1\n\n总结二分查找是一个很经典的算法，关键在于对循环条件的理解以及各种情况的判断，个人更喜欢第一种写法，相对更容易理解谢谢阅读！(。・ω・。)\n","slug":"artical3","date":"2023-01-24T07:08:42.505Z","categories_index":"算法","tags_index":"算法,二分查找","author_index":"莳雨"},{"id":"006076f8418c8c0b510fc49a5533190d","title":"寻找数组中和为定值的两个数","content":"问题描述输入一个整数数组和一个整数，在数组中查找一对数，满足他们的和正好是输入的那个整数\n方法：排序夹逼法（双指针扫描）若原数组无序，考虑先用sort对数组排序，但是如果题目要求输出数组下标，此方法就不太适用了（排序会打乱原数组的下标，输出的时候可能就需要多考虑一些东西了）数组有序之后，用两个指针分别指向数组头部和尾部，令begin&#x3D;0，end&#x3D;nums.end()-1，判断nums[begin]+nums[end]是否等于目标数target，若nums[begin]+nums[end] &gt; target，保持begin不变，让end–；反之，保持end不变，让begin++，while循环条件为begin &lt; end\n示例代码（保证数组升序排列）#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tprintf(&quot;请输入目标数\\n&quot;);\n\tint target; cin &gt;&gt; target;\n\tprintf(&quot;请输入数组元素个数\\n&quot;);\n\tint n; cin &gt;&gt; n;\n\tint* nums &#x3D; new int[n];\n\tprintf(&quot;请输入数组各元素\\n&quot;);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tcin &gt;&gt; nums[i];\n\tint begin &#x3D; 0, end &#x3D; n - 1;\n\twhile (begin &lt; end)\n\t&#123;\n\t\tif (nums[begin] + nums[end] &#x3D;&#x3D; target)\n\t\t&#123;\n\t\t\tprintf(&quot;和为%d的两元素为%d,%d\\n&quot;, target, nums[begin], nums[end]);\n\t\t\tprintf(&quot;它们是nums[%d]和nums[%d]\\n&quot;, begin, end);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse if (nums[begin] + nums[end] &lt; target)\n\t\t\tbegin++;\n\t\telse\n\t\t\tend--;\n\t&#125;\n\tdelete[] nums;\n\treturn 0;\n&#125;\n\n感谢阅读！！ヾ(•ω•&#96;)o\n","slug":"artical2","date":"2023-01-24T06:02:13.787Z","categories_index":"算法","tags_index":"算法","author_index":"莳雨"},{"id":"bcea4f6293f54fdbb1d383135d606a9c","title":"补题报告(1.16-1.23)","content":"本周完成的题目(共12题)，链接见下1001-随机序列1002-记数问题1003-约瑟夫环1004-校门外的树1005-比较月亮大小1006-求距离1007-数列下标1011-序列中整数去重1012-有序序列插入一个整数1013-打印质数表1015-有序序列合并1029-明明的随机数\n本周完成的比赛：牛客寒假训练赛1、2、3训练赛1A题题目链接：A-World Final? World Cup! (I)思路：枚举1-10场的情况，确定第i场能否决定胜负检查方式：剩余的 10-i 场里，假设最后A最高A1分、最低A2分，B最高B1分、 最低B2分，则可以确定胜负当且仅当：(A1-B2)(B1-A2)&lt;0代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint T;\nchar Arr[12];\nint main()\n&#123;\n\tcin &gt;&gt; T;\n\twhile (T--)\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t\t\tcin &gt;&gt; Arr[i];\n\t\tint A &#x3D; 0, B &#x3D; 0, flag &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t\t&#123;\n\t\t\tif (Arr[i] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tif (i % 2) A++;\n\t\t\t\telse B++;\n\t\t\t&#125;\n\t\t\tint A_best &#x3D; (10 - i) &#x2F; 2, B_best &#x3D; (11 - i) &#x2F; 2;\n\t\t\tif ((A + A_best - B) * (A - (B + B_best)) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t\t\t\tflag &#x3D; 0;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (flag) cout &lt;&lt; -1 &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nC题题目链接：C-现在是，学术时间 (I)思路：本题有坑，直接按每名教授分配1篇论文即为最高情况，因为H指数的定义决定它最大不会超过论文数，总论文数减去引用量为0的论文数即可代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint T,n,a[100005]\nint main()\n&#123;\n\tcin&gt;&gt;T;\n\twhile(T--)\n\t&#123;\n\t\tcin&gt;&gt;n;\n\t\tint ret&#x3D;0;\n\t\tfor(int i&#x3D;0;i&lt;n;i++)\n\t\t&#123;\n\t\t\tcin&gt;&gt;a[i];\n\t\t\tif(a[i]) ret++;\n\t\t&#125;\n\t\tcout&lt;&lt;ret&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n&#125;\n\nD题题目链接：D-现在是，学术时间 (II)思路：此题有4种情况，分类讨论即可首先另一个矩形顶点一定是ABCD之一，考虑P点坐标的四种情况，即下图四个区域• 区域1：枚举A、B、C、D作为另一顶点 的四种情况，取最大IOU；• 区域3：取A作为另一顶点；• 区域2：枚举A、B作为另一顶点的两种 情况，选较大的IOU；• 区域4：枚举A、D作为另一顶点的两种 情况，选较大的IOU；比赛时没有考虑这么多，所以没想到合适的解法代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nlong long x, y, xp, yp;\nint main()\n&#123;\n    int T; cin &gt;&gt; T;\n    while (T--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; xp &gt;&gt; yp;\n        double res &#x3D; 0;\n        if (xp &lt;&#x3D; x &amp;&amp; yp &lt;&#x3D; y)\n        &#123;\n            res &#x3D; max(xp * yp &#x2F; (double)(x * y), xp * (y - yp) &#x2F; (double)(x * y));\n            res &#x3D; max(res, (x - xp) * yp &#x2F; (double)(x * y));\n            res &#x3D; max(res, (x - xp) * (y - yp) &#x2F; (double)(x * y));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        if (xp &lt;&#x3D; x)\n        &#123;\n            res &#x3D; max(xp * y &#x2F; (double)(x * y + xp * (yp - y)),\n                (x - xp) * y &#x2F; (double)(x * y + (x - xp) * (yp - y)));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        if (yp &lt;&#x3D; y)\n        &#123;\n            res &#x3D; max(x * yp &#x2F; (double)(x * y + yp * (xp - x)),\n                x * (y - yp) &#x2F; (double)(x * y + (y - yp) * (xp - x)));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        res &#x3D; x * y &#x2F; (double)(xp * yp);\n        printf(&quot;%.10f\\n&quot;, res);\n    &#125;\n    return 0;\n&#125;\nH题题目链接：H-本题主要考察了DFS思路：拼图总造价是$10n^2$；拼图总造价 &#x3D; 给出拼图的造价 + 缺失拼图的造价，所以一减就行代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tint T; cin &gt;&gt; T;\n\twhile (T--)\n\t&#123;\n\t\tint n; cin &gt;&gt; n;\n\t\tint t &#x3D; n * n - 1;\n\t\tint m &#x3D; 0;\n\t\twhile (t--)\n\t\t&#123;\n\t\t\tstring a; cin &gt;&gt; a;\n\t\t\tint i, sum &#x3D; 10;\n\t\t\tfor (i &#x3D; 0; i &lt; 4; i++)\n\t\t\t&#123;\n\t\t\t\tif (a[i] &#x3D;&#x3D; &#39;1&#39;) sum--;\n\t\t\t\telse if (a[i] &#x3D;&#x3D; &#39;2&#39;) sum++;\n\t\t\t&#125;\n\t\t\tm +&#x3D; sum;\n\t\t&#125;\n\t\tcout &lt;&lt; 10 * n * n - m &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nK题题目链接：K-本题主要考察了dp思路：类似1001001001……11111这样的串（也就是密的部分全是1，松的部分一个1占多数的区间都没有）比较优，枚举i，在字符串前i个填上形如100100……的前缀，后面全填1，判断该串1的个数是否满足条件，满足则和当前答案取min即可代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int a[1010], ans &#x3D; 0;\n    memset(a, 0, sizeof(a));\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i +&#x3D; 3)\n    &#123;\n        a[i] &#x3D; 1;\n        m--;\n    &#125;\n    &#x2F;&#x2F; 先满足排列前面为100100......\n    for (int i &#x3D; n; m &gt; 0; i--)\n    &#123;\n        if (a[i]&#x3D;&#x3D;0)\n        &#123;\n            a[i] &#x3D; 1;\n            m--;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 再保证排列后面为111111111...\n    for (int i &#x3D; 1; i &lt;&#x3D; n - 2; i++)\n    &#123;\n        if (a[i] + a[i + 1] + a[i + 2] &gt;&#x3D; 2)\n            ans++;\n    &#125;\n    &#x2F;&#x2F; 判断各个区间是否为坏区间\n    cout &lt;&lt; ans;\n    return 0;\n&#125;\n训练赛2B题题目链接：B-Tokitsukaze and a+b&#x3D;n (medium)思路： a 的取值范围 [L1, R1]，满足 a + b &#x3D; n 的 b 的范围是 [n − L1, n − R1]，但是合法的 b 的范围是 [L2, R2] ，区间 [n − L1, n − R1] 与 [L2, R2] 取交后的区间长度即为答案。公式：两个区间 [a, b]，[c, d] 取交的区间长度为max(0, min(d, b) − max(a, c) + 1)代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main() &#123;\n    long long t, n, l1, l2, r1, r2, res;\n    cin&gt;&gt;t;\n    while (t--) \n    &#123; \n        cin&gt;&gt;n;\n        cin&gt;&gt;l1&gt;&gt;r1;\n        cin&gt;&gt;l2&gt;&gt;r2;\n        if(l1+l2&gt;n||r1+r2&lt;n)\n            cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;\n        else\n            cout&lt;&lt;abs(max(l1,n-r2)-min(n-l2,r1))+1&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\nD题题目链接：D-Tokitsukaze and Energy Tree思路：经典结论，两个向量内部允许任意重排，则点积最大方法为都升序排列可以发现当第 i 个能量球放置在节点 x 时，它的贡献为：节点 1 到节点 x 的高度 hx * 能量球的能量 vi ，求出高度 h 后，分别对高度 h 和 能量 v 排序，之后大的乘大的，再全部加起来即可代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n&#123;\n\tll n, i, f, sum &#x3D; 0; cin &gt;&gt; n;\n\tll a[300000] &#x3D; &#123; 0 &#125;, b[300000] &#x3D; &#123; 0 &#125;;\n\ta[1] &#x3D; 1;\n\tfor (i &#x3D; 2; i &lt;&#x3D; n; i++) \n\t&#123;\n\t\tcin &gt;&gt; f;\n\t\ta[i] &#x3D; a[f] + 1;\n\t&#125;\n\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tcin &gt;&gt; b[i];\n\tsort(a + 1, a + 1 + n);\n\tsort(b + 1, b + 1 + n);\n\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\tsum &#x3D; sum + a[i] * b[i];\n\tcout &lt;&lt; sum;\n\treturn 0;\n&#125;\nH题题目链接：H-Tokitsukaze and K-Sequence思路：每种数字的贡献可以分开计算。按照每种数字出现的次数进行讨论假设数字$x$出现的次数为 $cnt_x$， 如果$cnt_x\\le k$，可以贪心地将每个$x$都分到某个子序列中，使得每个子序列要么只包含 1 个$x$，要么不包含$x$，所以此时数字$x$的贡献为$cnt_x$ ，如果$cnt_x &gt; k$，我们按照上面的方法分配完$k$个$x$，多出来的$x$必须分配到某个子序列中，导致 那个子序列中，数字$x$没有贡献。所以此时数字$x$的贡献为$k-1$，答案就是每种数字的贡献求和求$k &#x3D; 1···n$的答案，对 $cnt$ 从小到大排序，枚举$k &#x3D; 1···n$，答案为 $cnt_x\\le k$的$cnt_x$求和，加上$cnt_x &gt; k$的 $cnt_x$ 的个数乘上$(k-1)$代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a[100005];\nint main() \n&#123;\n\tint t; cin &gt;&gt; t;\n\twhile (t--) \n\t&#123;\n\t\tint n; cin &gt;&gt; n;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tcin &gt;&gt; a[i];\n\t\tsort(a, a + n);\n\t\tint cnt[100005], b &#x3D; 1, c &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t&#123;\n\t\t\tif (a[i] &#x3D;&#x3D; a[i - 1]) b++;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tcnt[c++] &#x3D; b;\n\t\t\t\tb &#x3D; 1;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcnt[c++] &#x3D; b;\n\t\tsort(cnt, cnt + c);\n\t\tint k &#x3D; 0, ans1 &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\twhile (k &lt; c)\n\t\t\t&#123;\n\t\t\t\tif (cnt[k] &lt;&#x3D; i)\n\t\t\t\t&#123;\n\t\t\t\t\tans1 +&#x3D; cnt[k];\n\t\t\t\t\tk++;\n\t\t\t\t&#125;\n\t\t\t\telse break;\n\t\t\t&#125;\n\t\t\tint ans2 &#x3D; (c - k) * (i - 1);\n\t\t\tcout &lt;&lt; ans1 + ans2 &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\nJ题题目链接：J-Tokitsukaze and Sum of MxAb思路：先对题目给的式子分情况讨论，再化简，可得$max(|a_i-a_j|,|a_i+a_j|)&#x3D;|a_i|+|a_j|$，则题目要求的式子可化为$2·n·\\textstyle\\sum_{i&#x3D;1}^n|a_i|$，据此求解即可代码实现：\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint t,a[100005];\nint mxab(int x,int y)\n&#123;\n    return max(abs(x-y),abs(x+y));\n&#125;\nint main ()\n&#123;\n    cin&gt;&gt;t;\n    while(t--)\n    &#123;\n        int n; cin&gt;&gt;n;\n        long long sum&#x3D;0;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            cin&gt;&gt;a[i];\n            sum+&#x3D;abs(a[i]);\n        &#125;\n        cout&lt;&lt;sum*n*2&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n训练赛3B题题目链接：B-勉强拼凑的记忆思路：这道题可以试着推演找规律，也可以二分假设答案为ans，ans必定满足$\\lceil\\frac{n}{2}\\rceil\\le ans\\le n$(取$\\lceil\\frac{n}{2}\\rceil$块时一定有解)画图得到最优情况下ans满足$ans\\le\\frac{n+2\\lceil\\frac{n}{2}\\rceil}{3}$代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n&#123;\n\tint t; cin &gt;&gt; t;\n\twhile(t--)\n\t&#123;\n\t\tll x; cin &gt;&gt; x;\n\t\tif (x &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tcout &lt;&lt; 1 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tif (x &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tcout &lt;&lt; -1 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tll ans &#x3D; (x + 2 * ((x + 1) &#x2F; 2) &#x2F; 3);\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nC题题目链接：C-忽远忽近的距离思路：构造题，原则：找到一个既有一般性，又有可行性的构造原则，本题按照n模4的余数来进行分类(比赛时自己只考虑到了3类，没有考虑n模4余3的场合)，按n分为n&#x3D;4k,n&#x3D;4k+5,n&#x3D;4k+6,n&#x3D;4k+5+6四种情况，注意n&#x3D;7是无解的(当时在这里误判了，导致最后只做了3种情况)，每种情况把数字按数量分成4个和5个这两类小块，参考样例格式输出即可代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint cnt&#x3D;0,a[100005];\nvoid f0(int n)\n&#123;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n    &#123;\n        if(i%4&#x3D;&#x3D;1) a[i]&#x3D;3+cnt*4;\n        if(i%4&#x3D;&#x3D;2) a[i]&#x3D;4+cnt*4;\n        if(i%4&#x3D;&#x3D;3) a[i]&#x3D;1+cnt*4;\n        if(i%4&#x3D;&#x3D;0)\n        &#123;\n            a[i]&#x3D;2+cnt*4;\n            cnt++;\n        &#125;\n    &#125;\n&#125;\nvoid f1(int n)\n&#123;\n    f0(n-5);\n    a[n-4]&#x3D;4+cnt*4;\n    a[n-3]&#x3D;5+cnt*4;\n    a[n-2]&#x3D;1+cnt*4;\n    a[n-1]&#x3D;2+cnt*4;\n    a[n]&#x3D;3+cnt*4;\n&#125;\nvoid f2(int n)\n&#123;\n    f0(n-6);\n    a[n-5]&#x3D;4+cnt*4;\n    a[n-4]&#x3D;5+cnt*4;\n    a[n-3]&#x3D;6+cnt*4;\n    a[n-2]&#x3D;1+cnt*4;\n    a[n-1]&#x3D;2+cnt*4;\n    a[n]&#x3D;3+cnt*4;\n&#125;\nvoid f3(int n)\n&#123;\n    f0(n-11);\n    a[n-10]&#x3D;4+cnt*4;\n    a[n-9]&#x3D;5+cnt*4;\n    a[n-8]&#x3D;1+cnt*4;\n    a[n-7]&#x3D;2+cnt*4;\n    a[n-6]&#x3D;3+cnt*4;\n    cnt++;\n    a[n-5]&#x3D;4+cnt*4+1;\n    a[n-4]&#x3D;5+cnt*4+1;\n    a[n-3]&#x3D;6+cnt*4+1;\n    a[n-2]&#x3D;1+cnt*4+1;\n    a[n-1]&#x3D;2+cnt*4+1;\n    a[n]&#x3D;3+cnt*4+1;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    if(n&lt;4||n&#x3D;&#x3D;7) cout&lt;&lt;&quot;-1&quot;;\n    else\n    &#123;\n        if(n%4&#x3D;&#x3D;0) f0(n);\n        if(n%4&#x3D;&#x3D;1) f1(n);\n        if(n%4&#x3D;&#x3D;2) f2(n);\n        if(n%4&#x3D;&#x3D;3) f3(n);\n         for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n         &#123;\n            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nE题题目链接：E-公平守望的灯塔思路：这题用向量就行，先设AB中点为M，要求的点为C，易求出M点坐标，然后利用高中数学知识求出$\\overrightarrow{MC}$，这样就能求出C点坐标了代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nll xa, ya, xb, yb, xm, ym;\nint main() \n&#123;\n\tcin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n\txa *&#x3D; 2; ya *&#x3D; 2; xb *&#x3D; 2; yb *&#x3D; 2;\n\txm &#x3D; (xa + xb) &#x2F; 2ll;\n\tym &#x3D; (ya + yb) &#x2F; 2ll;\n\tll dx &#x3D; xm - xa, dy &#x3D; ym - ya;\n\tif ((xm + dy) % 2ll &#x3D;&#x3D; 0 &amp;&amp; (ym - dx) % 2ll &#x3D;&#x3D; 0) \n\t\tprintf(&quot;%lld %lld\\n&quot;, (xm + dy) &#x2F; 2ll, (ym - dx) &#x2F; 2ll);\n\telse if ((xm - dy) % 2ll &#x3D;&#x3D; 0 &amp;&amp; (ym + dx) % 2ll &#x3D;&#x3D; 0) \n\t\tprintf(&quot;%lld %lld\\n&quot;, (xm - dy) &#x2F; 2ll, (ym + dx) &#x2F; 2ll);\n\telse \n\t\tputs(&quot;No Answer!&quot;);\n\treturn 0;\n&#125;","slug":"artical1","date":"2023-01-23T13:31:23.057Z","categories_index":"杂念","tags_index":"算法","author_index":"莳雨"}]