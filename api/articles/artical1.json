{"title":"补题报告(1.16-1.23)","uid":"bcea4f6293f54fdbb1d383135d606a9c","slug":"artical1","date":"2023-01-23T13:31:23.057Z","updated":"2023-01-24T03:01:24.135Z","comments":true,"path":"api/articles/artical1.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63cf4997588a5d166c8f65bd.png","content":"<h1 id=\"本周完成的题目-共12题-，链接见下\"><a href=\"#本周完成的题目-共12题-，链接见下\" class=\"headerlink\" title=\"本周完成的题目(共12题)，链接见下\"></a>本周完成的题目(共12题)，链接见下</h1><p><a href=\"https://ac.nowcoder.com/acm/contest/19306/1001\">1001-随机序列</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1002\">1002-记数问题</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1003\">1003-约瑟夫环</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1004\">1004-校门外的树</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1005\">1005-比较月亮大小</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1006\">1006-求距离</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1007\">1007-数列下标</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1011\">1011-序列中整数去重</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1012\">1012-有序序列插入一个整数</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1013\">1013-打印质数表</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1015\">1015-有序序列合并</a><br><a href=\"https://ac.nowcoder.com/acm/contest/19306/1029\">1029-明明的随机数</a></p>\n<h1 id=\"本周完成的比赛：牛客寒假训练赛1、2、3\"><a href=\"#本周完成的比赛：牛客寒假训练赛1、2、3\" class=\"headerlink\" title=\"本周完成的比赛：牛客寒假训练赛1、2、3\"></a>本周完成的比赛：牛客寒假训练赛1、2、3</h1><h2 id=\"训练赛1\"><a href=\"#训练赛1\" class=\"headerlink\" title=\"训练赛1\"></a>训练赛1</h2><h3 id=\"A题\"><a href=\"#A题\" class=\"headerlink\" title=\"A题\"></a>A题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46800/A\">A-World Final? World Cup! (I)</a><br><strong>思路</strong>：枚举1-10场的情况，确定第i场能否决定胜负<br><strong>检查方式</strong>：剩余的 10-i 场里，假设最后A最高A1分、最低A2分，B最高B1分、 最低B2分，则可以确定胜负当且仅当：(A1-B2)(B1-A2)&lt;0<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint T;\nchar Arr[12];\nint main()\n&#123;\n\tcin &gt;&gt; T;\n\twhile (T--)\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t\t\tcin &gt;&gt; Arr[i];\n\t\tint A &#x3D; 0, B &#x3D; 0, flag &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t\t&#123;\n\t\t\tif (Arr[i] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tif (i % 2) A++;\n\t\t\t\telse B++;\n\t\t\t&#125;\n\t\t\tint A_best &#x3D; (10 - i) &#x2F; 2, B_best &#x3D; (11 - i) &#x2F; 2;\n\t\t\tif ((A + A_best - B) * (A - (B + B_best)) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; i &lt;&lt; endl;\n\t\t\t\tflag &#x3D; 0;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (flag) cout &lt;&lt; -1 &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n<h3 id=\"C题\"><a href=\"#C题\" class=\"headerlink\" title=\"C题\"></a>C题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46800/C\">C-现在是，学术时间 (I)</a><br><strong>思路</strong>：本题有坑，直接按每名教授分配1篇论文即为最高情况，因为H指数的定义决定它最大不会超过论文数，总论文数减去引用量为0的论文数即可<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint T,n,a[100005]\nint main()\n&#123;\n\tcin&gt;&gt;T;\n\twhile(T--)\n\t&#123;\n\t\tcin&gt;&gt;n;\n\t\tint ret&#x3D;0;\n\t\tfor(int i&#x3D;0;i&lt;n;i++)\n\t\t&#123;\n\t\t\tcin&gt;&gt;a[i];\n\t\t\tif(a[i]) ret++;\n\t\t&#125;\n\t\tcout&lt;&lt;ret&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n<h3 id=\"D题\"><a href=\"#D题\" class=\"headerlink\" title=\"D题\"></a>D题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46800/D\">D-现在是，学术时间 (II)</a><br><strong>思路</strong>：此题有4种情况，分类讨论即可<br>首先另一个矩形顶点一定是ABCD之一，考虑P点坐标的四种情况，即下图四个区域<br>• 区域1：枚举A、B、C、D作为另一顶点 的四种情况，取最大IOU；<br>• 区域3：取A作为另一顶点；<br>• 区域2：枚举A、B作为另一顶点的两种 情况，选较大的IOU；<br>• 区域4：枚举A、D作为另一顶点的两种 情况，选较大的IOU；<br><img src=\"https://pic.imgdb.cn/item/63ce7b45588a5d166c4ba271.png\" alt=\"图片\"><br>比赛时没有考虑这么多，所以没想到合适的解法<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nlong long x, y, xp, yp;\nint main()\n&#123;\n    int T; cin &gt;&gt; T;\n    while (T--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; xp &gt;&gt; yp;\n        double res &#x3D; 0;\n        if (xp &lt;&#x3D; x &amp;&amp; yp &lt;&#x3D; y)\n        &#123;\n            res &#x3D; max(xp * yp &#x2F; (double)(x * y), xp * (y - yp) &#x2F; (double)(x * y));\n            res &#x3D; max(res, (x - xp) * yp &#x2F; (double)(x * y));\n            res &#x3D; max(res, (x - xp) * (y - yp) &#x2F; (double)(x * y));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        if (xp &lt;&#x3D; x)\n        &#123;\n            res &#x3D; max(xp * y &#x2F; (double)(x * y + xp * (yp - y)),\n                (x - xp) * y &#x2F; (double)(x * y + (x - xp) * (yp - y)));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        if (yp &lt;&#x3D; y)\n        &#123;\n            res &#x3D; max(x * yp &#x2F; (double)(x * y + yp * (xp - x)),\n                x * (y - yp) &#x2F; (double)(x * y + (y - yp) * (xp - x)));\n            printf(&quot;%.10f\\n&quot;, res);\n            continue;\n        &#125;\n        res &#x3D; x * y &#x2F; (double)(xp * yp);\n        printf(&quot;%.10f\\n&quot;, res);\n    &#125;\n    return 0;\n&#125;</code></pre>\n<h3 id=\"H题\"><a href=\"#H题\" class=\"headerlink\" title=\"H题\"></a>H题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46800/H\">H-本题主要考察了DFS</a><br><strong>思路</strong>：拼图总造价是$10n^2$；拼图总造价 &#x3D; 给出拼图的造价 + 缺失拼图的造价，所以一减就行<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tint T; cin &gt;&gt; T;\n\twhile (T--)\n\t&#123;\n\t\tint n; cin &gt;&gt; n;\n\t\tint t &#x3D; n * n - 1;\n\t\tint m &#x3D; 0;\n\t\twhile (t--)\n\t\t&#123;\n\t\t\tstring a; cin &gt;&gt; a;\n\t\t\tint i, sum &#x3D; 10;\n\t\t\tfor (i &#x3D; 0; i &lt; 4; i++)\n\t\t\t&#123;\n\t\t\t\tif (a[i] &#x3D;&#x3D; &#39;1&#39;) sum--;\n\t\t\t\telse if (a[i] &#x3D;&#x3D; &#39;2&#39;) sum++;\n\t\t\t&#125;\n\t\t\tm +&#x3D; sum;\n\t\t&#125;\n\t\tcout &lt;&lt; 10 * n * n - m &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n<h3 id=\"K题\"><a href=\"#K题\" class=\"headerlink\" title=\"K题\"></a>K题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46800/K\">K-本题主要考察了dp</a><br><strong>思路</strong>：类似1001001001……11111这样的串（也就是密的部分全是1，松的部分一个1占多数的区间都没有）比较优，枚举i，在字符串前i个填上形如100100……的前缀，后面全填1，判断该串1的个数是否满足条件，满足则和当前答案取min即可<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int a[1010], ans &#x3D; 0;\n    memset(a, 0, sizeof(a));\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i +&#x3D; 3)\n    &#123;\n        a[i] &#x3D; 1;\n        m--;\n    &#125;\n    &#x2F;&#x2F; 先满足排列前面为100100......\n    for (int i &#x3D; n; m &gt; 0; i--)\n    &#123;\n        if (a[i]&#x3D;&#x3D;0)\n        &#123;\n            a[i] &#x3D; 1;\n            m--;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 再保证排列后面为111111111...\n    for (int i &#x3D; 1; i &lt;&#x3D; n - 2; i++)\n    &#123;\n        if (a[i] + a[i + 1] + a[i + 2] &gt;&#x3D; 2)\n            ans++;\n    &#125;\n    &#x2F;&#x2F; 判断各个区间是否为坏区间\n    cout &lt;&lt; ans;\n    return 0;\n&#125;</code></pre>\n<h2 id=\"训练赛2\"><a href=\"#训练赛2\" class=\"headerlink\" title=\"训练赛2\"></a>训练赛2</h2><h3 id=\"B题\"><a href=\"#B题\" class=\"headerlink\" title=\"B题\"></a>B题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46810/B\">B-Tokitsukaze and a+b&#x3D;n (medium)</a><br><strong>思路</strong>： a 的取值范围 [L1, R1]，满足 a + b &#x3D; n 的 b 的范围是 [n − L1, n − R1]，但是合法的 b 的范围是 [L2, R2] ，区间 [n − L1, n − R1] 与 [L2, R2] 取交后的区间长度即为答案。<br>公式：两个区间 [a, b]，[c, d] 取交的区间长度为max(0, min(d, b) − max(a, c) + 1)<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main() &#123;\n    long long t, n, l1, l2, r1, r2, res;\n    cin&gt;&gt;t;\n    while (t--) \n    &#123; \n        cin&gt;&gt;n;\n        cin&gt;&gt;l1&gt;&gt;r1;\n        cin&gt;&gt;l2&gt;&gt;r2;\n        if(l1+l2&gt;n||r1+r2&lt;n)\n            cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;\n        else\n            cout&lt;&lt;abs(max(l1,n-r2)-min(n-l2,r1))+1&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;</code></pre>\n<h3 id=\"D题-1\"><a href=\"#D题-1\" class=\"headerlink\" title=\"D题\"></a>D题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46810/D\">D-Tokitsukaze and Energy Tree</a><br><strong>思路</strong>：经典结论，两个向量内部允许任意重排，则点积最大方法为都升序排列<br>可以发现当第 i 个能量球放置在节点 x 时，它的贡献为：节点 1 到节点 x 的高度 hx * 能量球的能量 vi ，求出高度 h 后，分别对高度 h 和 能量 v 排序，之后大的乘大的，再全部加起来即可<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n&#123;\n\tll n, i, f, sum &#x3D; 0; cin &gt;&gt; n;\n\tll a[300000] &#x3D; &#123; 0 &#125;, b[300000] &#x3D; &#123; 0 &#125;;\n\ta[1] &#x3D; 1;\n\tfor (i &#x3D; 2; i &lt;&#x3D; n; i++) \n\t&#123;\n\t\tcin &gt;&gt; f;\n\t\ta[i] &#x3D; a[f] + 1;\n\t&#125;\n\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tcin &gt;&gt; b[i];\n\tsort(a + 1, a + 1 + n);\n\tsort(b + 1, b + 1 + n);\n\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\tsum &#x3D; sum + a[i] * b[i];\n\tcout &lt;&lt; sum;\n\treturn 0;\n&#125;</code></pre>\n<h3 id=\"H题-1\"><a href=\"#H题-1\" class=\"headerlink\" title=\"H题\"></a>H题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46810/H\">H-Tokitsukaze and K-Sequence</a><br><strong>思路</strong>：每种数字的贡献可以分开计算。按照每种数字出现的次数进行讨论<br>假设数字$x$出现的次数为 $cnt_x$， 如果$cnt_x\\le k$，可以贪心地将每个$x$都分到某个子序列中，使得每个子序列要么只包含 1 个$x$，要么不包含$x$，所以此时数字$x$的贡献为$cnt_x$ ，如果$cnt_x &gt; k$，我们按照上面的方法分配完$k$个$x$，多出来的$x$必须分配到某个子序列中，导致 那个子序列中，数字$x$没有贡献。所以此时数字$x$的贡献为$k-1$，答案就是每种数字的贡献求和<br>求$k &#x3D; 1···n$的答案，对 $cnt$ 从小到大排序，枚举$k &#x3D; 1···n$，答案为 $cnt_x\\le k$的$cnt_x$求和，加上$cnt_x &gt; k$的 $cnt_x$ 的个数乘上$(k-1)$<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a[100005];\nint main() \n&#123;\n\tint t; cin &gt;&gt; t;\n\twhile (t--) \n\t&#123;\n\t\tint n; cin &gt;&gt; n;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tcin &gt;&gt; a[i];\n\t\tsort(a, a + n);\n\t\tint cnt[100005], b &#x3D; 1, c &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t&#123;\n\t\t\tif (a[i] &#x3D;&#x3D; a[i - 1]) b++;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tcnt[c++] &#x3D; b;\n\t\t\t\tb &#x3D; 1;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcnt[c++] &#x3D; b;\n\t\tsort(cnt, cnt + c);\n\t\tint k &#x3D; 0, ans1 &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\twhile (k &lt; c)\n\t\t\t&#123;\n\t\t\t\tif (cnt[k] &lt;&#x3D; i)\n\t\t\t\t&#123;\n\t\t\t\t\tans1 +&#x3D; cnt[k];\n\t\t\t\t\tk++;\n\t\t\t\t&#125;\n\t\t\t\telse break;\n\t\t\t&#125;\n\t\t\tint ans2 &#x3D; (c - k) * (i - 1);\n\t\t\tcout &lt;&lt; ans1 + ans2 &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n<h3 id=\"J题\"><a href=\"#J题\" class=\"headerlink\" title=\"J题\"></a>J题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46810/J\">J-Tokitsukaze and Sum of MxAb</a><br><strong>思路</strong>：先对题目给的式子分情况讨论，再化简，可得<br>$max(|a_i-a_j|,|a_i+a_j|)&#x3D;|a_i|+|a_j|$，则题目要求的式子可化为$2·n·\\textstyle\\sum_{i&#x3D;1}^n|a_i|$，据此求解即可<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint t,a[100005];\nint mxab(int x,int y)\n&#123;\n    return max(abs(x-y),abs(x+y));\n&#125;\nint main ()\n&#123;\n    cin&gt;&gt;t;\n    while(t--)\n    &#123;\n        int n; cin&gt;&gt;n;\n        long long sum&#x3D;0;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            cin&gt;&gt;a[i];\n            sum+&#x3D;abs(a[i]);\n        &#125;\n        cout&lt;&lt;sum*n*2&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;</code></pre>\n<h2 id=\"训练赛3\"><a href=\"#训练赛3\" class=\"headerlink\" title=\"训练赛3\"></a>训练赛3</h2><h3 id=\"B题-1\"><a href=\"#B题-1\" class=\"headerlink\" title=\"B题\"></a>B题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46811/B\">B-勉强拼凑的记忆</a><br><strong>思路</strong>：这道题可以试着推演找规律，也可以二分<br>假设答案为ans，ans必定满足$\\lceil\\frac{n}{2}\\rceil\\le ans\\le n$(取$\\lceil\\frac{n}{2}\\rceil$块时一定有解)<br>画图得到最优情况下ans满足$ans\\le\\frac{n+2\\lceil\\frac{n}{2}\\rceil}{3}$<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n&#123;\n\tint t; cin &gt;&gt; t;\n\twhile(t--)\n\t&#123;\n\t\tll x; cin &gt;&gt; x;\n\t\tif (x &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tcout &lt;&lt; 1 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tif (x &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tcout &lt;&lt; -1 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tll ans &#x3D; (x + 2 * ((x + 1) &#x2F; 2) &#x2F; 3);\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n<h3 id=\"C题-1\"><a href=\"#C题-1\" class=\"headerlink\" title=\"C题\"></a>C题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46811/C\">C-忽远忽近的距离</a><br><strong>思路</strong>：构造题，原则：找到一个既有一般性，又有可行性的构造原则，本题按照n模4的余数来进行分类(比赛时自己只考虑到了3类，没有考虑n模4余3的场合)，按n分为n&#x3D;4k,n&#x3D;4k+5,n&#x3D;4k+6,n&#x3D;4k+5+6四种情况，注意n&#x3D;7是无解的(当时在这里误判了，导致最后只做了3种情况)，每种情况把数字按数量分成4个和5个这两类小块，参考样例格式输出即可<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint cnt&#x3D;0,a[100005];\nvoid f0(int n)\n&#123;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n    &#123;\n        if(i%4&#x3D;&#x3D;1) a[i]&#x3D;3+cnt*4;\n        if(i%4&#x3D;&#x3D;2) a[i]&#x3D;4+cnt*4;\n        if(i%4&#x3D;&#x3D;3) a[i]&#x3D;1+cnt*4;\n        if(i%4&#x3D;&#x3D;0)\n        &#123;\n            a[i]&#x3D;2+cnt*4;\n            cnt++;\n        &#125;\n    &#125;\n&#125;\nvoid f1(int n)\n&#123;\n    f0(n-5);\n    a[n-4]&#x3D;4+cnt*4;\n    a[n-3]&#x3D;5+cnt*4;\n    a[n-2]&#x3D;1+cnt*4;\n    a[n-1]&#x3D;2+cnt*4;\n    a[n]&#x3D;3+cnt*4;\n&#125;\nvoid f2(int n)\n&#123;\n    f0(n-6);\n    a[n-5]&#x3D;4+cnt*4;\n    a[n-4]&#x3D;5+cnt*4;\n    a[n-3]&#x3D;6+cnt*4;\n    a[n-2]&#x3D;1+cnt*4;\n    a[n-1]&#x3D;2+cnt*4;\n    a[n]&#x3D;3+cnt*4;\n&#125;\nvoid f3(int n)\n&#123;\n    f0(n-11);\n    a[n-10]&#x3D;4+cnt*4;\n    a[n-9]&#x3D;5+cnt*4;\n    a[n-8]&#x3D;1+cnt*4;\n    a[n-7]&#x3D;2+cnt*4;\n    a[n-6]&#x3D;3+cnt*4;\n    cnt++;\n    a[n-5]&#x3D;4+cnt*4+1;\n    a[n-4]&#x3D;5+cnt*4+1;\n    a[n-3]&#x3D;6+cnt*4+1;\n    a[n-2]&#x3D;1+cnt*4+1;\n    a[n-1]&#x3D;2+cnt*4+1;\n    a[n]&#x3D;3+cnt*4+1;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    if(n&lt;4||n&#x3D;&#x3D;7) cout&lt;&lt;&quot;-1&quot;;\n    else\n    &#123;\n        if(n%4&#x3D;&#x3D;0) f0(n);\n        if(n%4&#x3D;&#x3D;1) f1(n);\n        if(n%4&#x3D;&#x3D;2) f2(n);\n        if(n%4&#x3D;&#x3D;3) f3(n);\n         for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n         &#123;\n            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n<h3 id=\"E题\"><a href=\"#E题\" class=\"headerlink\" title=\"E题\"></a>E题</h3><p><strong>题目链接</strong>：<a href=\"https://ac.nowcoder.com/acm/contest/46811/E\">E-公平守望的灯塔</a><br><strong>思路</strong>：这题用向量就行，先设AB中点为M，要求的点为C，易求出M点坐标，然后利用高中数学知识求出$\\overrightarrow{MC}$，这样就能求出C点坐标了<br><strong>代码实现</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nll xa, ya, xb, yb, xm, ym;\nint main() \n&#123;\n\tcin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n\txa *&#x3D; 2; ya *&#x3D; 2; xb *&#x3D; 2; yb *&#x3D; 2;\n\txm &#x3D; (xa + xb) &#x2F; 2ll;\n\tym &#x3D; (ya + yb) &#x2F; 2ll;\n\tll dx &#x3D; xm - xa, dy &#x3D; ym - ya;\n\tif ((xm + dy) % 2ll &#x3D;&#x3D; 0 &amp;&amp; (ym - dx) % 2ll &#x3D;&#x3D; 0) \n\t\tprintf(&quot;%lld %lld\\n&quot;, (xm + dy) &#x2F; 2ll, (ym - dx) &#x2F; 2ll);\n\telse if ((xm - dy) % 2ll &#x3D;&#x3D; 0 &amp;&amp; (ym + dx) % 2ll &#x3D;&#x3D; 0) \n\t\tprintf(&quot;%lld %lld\\n&quot;, (xm - dy) &#x2F; 2ll, (ym + dx) &#x2F; 2ll);\n\telse \n\t\tputs(&quot;No Answer!&quot;);\n\treturn 0;\n&#125;</code></pre>","text":"本周完成的题目(共12题)，链接见下1001-随机序列1002-记数问题1003-约瑟夫环1004-校门外的树1005-比较月亮大小1006-求距离1007-数列下标1011-序列中整数去重1012-有序序列插入一个整数1013-打印质数表1015-有序序列合并1029-明明的随...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%91%A8%E5%AE%8C%E6%88%90%E7%9A%84%E9%A2%98%E7%9B%AE-%E5%85%B112%E9%A2%98-%EF%BC%8C%E9%93%BE%E6%8E%A5%E8%A7%81%E4%B8%8B\"><span class=\"toc-text\">本周完成的题目(共12题)，链接见下</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%91%A8%E5%AE%8C%E6%88%90%E7%9A%84%E6%AF%94%E8%B5%9B%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%B5%9B1%E3%80%812%E3%80%813\"><span class=\"toc-text\">本周完成的比赛：牛客寒假训练赛1、2、3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%AD%E7%BB%83%E8%B5%9B1\"><span class=\"toc-text\">训练赛1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#A%E9%A2%98\"><span class=\"toc-text\">A题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C%E9%A2%98\"><span class=\"toc-text\">C题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#D%E9%A2%98\"><span class=\"toc-text\">D题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#H%E9%A2%98\"><span class=\"toc-text\">H题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#K%E9%A2%98\"><span class=\"toc-text\">K题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%AD%E7%BB%83%E8%B5%9B2\"><span class=\"toc-text\">训练赛2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B%E9%A2%98\"><span class=\"toc-text\">B题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#D%E9%A2%98-1\"><span class=\"toc-text\">D题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#H%E9%A2%98-1\"><span class=\"toc-text\">H题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#J%E9%A2%98\"><span class=\"toc-text\">J题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%AD%E7%BB%83%E8%B5%9B3\"><span class=\"toc-text\">训练赛3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B%E9%A2%98-1\"><span class=\"toc-text\">B题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C%E9%A2%98-1\"><span class=\"toc-text\">C题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#E%E9%A2%98\"><span class=\"toc-text\">E题</span></a></li></ol></li></ol></li></ol>","author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}},"mapped":true,"prev_post":{"title":"寻找数组中和为定值的两个数","uid":"006076f8418c8c0b510fc49a5533190d","slug":"artical2","date":"2023-01-24T06:02:13.787Z","updated":"2023-01-24T06:03:39.867Z","comments":true,"path":"api/articles/artical2.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63cf73cf588a5d166ce0a667.jpg","text":"问题描述输入一个整数数组和一个整数，在数组中查找一对数，满足他们的和正好是输入的那个整数 方法：排序夹逼法（双指针扫描）若原数组无序，考虑先用sort对数组排序，但是如果题目要求输出数组下标，此方法就不太适用了（排序会打乱原数组的下标，输出的时候可能就需要多考虑一些东西了）数组有...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}}},"next_post":{}}