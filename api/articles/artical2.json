{"title":"寻找数组中和为定值的两个数","uid":"006076f8418c8c0b510fc49a5533190d","slug":"artical2","date":"2023-01-24T06:02:13.787Z","updated":"2023-01-24T06:03:39.867Z","comments":true,"path":"api/articles/artical2.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63cf73cf588a5d166ce0a667.jpg","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>输入一个整数数组和一个整数，在数组中查找一对数，满足他们的和正好是输入的那个整数</p>\n<h1 id=\"方法：排序夹逼法（双指针扫描）\"><a href=\"#方法：排序夹逼法（双指针扫描）\" class=\"headerlink\" title=\"方法：排序夹逼法（双指针扫描）\"></a>方法：排序夹逼法（双指针扫描）</h1><p>若原数组无序，考虑先用sort对数组排序，但是如果题目要求输出数组下标，此方法就不太适用了（排序会打乱原数组的下标，输出的时候可能就需要多考虑一些东西了）<br>数组有序之后，用两个指针分别指向数组头部和尾部，令begin&#x3D;0，end&#x3D;nums.end()-1，判断nums[begin]+nums[end]是否等于目标数target，若nums[begin]+nums[end] &gt; target，保持begin不变，让end–；反之，保持end不变，让begin++，while循环条件为begin &lt; end</p>\n<h1 id=\"示例代码（保证数组升序排列）\"><a href=\"#示例代码（保证数组升序排列）\" class=\"headerlink\" title=\"示例代码（保证数组升序排列）\"></a>示例代码（保证数组升序排列）</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tprintf(&quot;请输入目标数\\n&quot;);\n\tint target; cin &gt;&gt; target;\n\tprintf(&quot;请输入数组元素个数\\n&quot;);\n\tint n; cin &gt;&gt; n;\n\tint* nums &#x3D; new int[n];\n\tprintf(&quot;请输入数组各元素\\n&quot;);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tcin &gt;&gt; nums[i];\n\tint begin &#x3D; 0, end &#x3D; n - 1;\n\twhile (begin &lt; end)\n\t&#123;\n\t\tif (nums[begin] + nums[end] &#x3D;&#x3D; target)\n\t\t&#123;\n\t\t\tprintf(&quot;和为%d的两元素为%d,%d\\n&quot;, target, nums[begin], nums[end]);\n\t\t\tprintf(&quot;它们是nums[%d]和nums[%d]\\n&quot;, begin, end);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse if (nums[begin] + nums[end] &lt; target)\n\t\t\tbegin++;\n\t\telse\n\t\t\tend--;\n\t&#125;\n\tdelete[] nums;\n\treturn 0;\n&#125;</code></pre>\n\n<p><strong>感谢阅读！！ヾ(•ω•&#96;)o</strong></p>\n","text":"问题描述输入一个整数数组和一个整数，在数组中查找一对数，满足他们的和正好是输入的那个整数 方法：排序夹逼法（双指针扫描）若原数组无序，考虑先用sort对数组排序，但是如果题目要求输出数组下标，此方法就不太适用了（排序会打乱原数组的下标，输出的时候可能就需要多考虑一些东西了）数组有...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">问题描述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%A4%B9%E9%80%BC%E6%B3%95%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F%EF%BC%89\"><span class=\"toc-text\">方法：排序夹逼法（双指针扫描）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BF%9D%E8%AF%81%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%89\"><span class=\"toc-text\">示例代码（保证数组升序排列）</span></a></li></ol>","author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}},"mapped":true,"prev_post":{},"next_post":{}}