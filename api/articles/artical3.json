{"title":"二分查找","uid":"d843ced03f40ac612213952de4b63ad2","slug":"artical3","date":"2023-01-24T07:08:42.505Z","updated":"2023-01-24T09:02:00.883Z","comments":true,"path":"api/articles/artical3.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63cf9dc9588a5d166c3e6ee8.jpg","content":"<p>本文参考了CSDN上的相关文章，原文链接见下<br>(原文写的非常非常好，强烈建议去看看！)<br><a href=\"https://blog.csdn.net/qq_45978890/article/details/116094046\">【二分查找】详细图解_Charon_cc的博客-CSDN博客-二分查找</a>)</p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>要使用二分查找，需要满足：<br><strong>1.要查找的内容在逻辑上是有序的(比如升序、降序)<br>2.只能查找一个元素</strong><br>在满足这两个前提之后，要求我们查找数组中的指定元素时就可以使用二分查找了，这种方法的效率比较高</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>在二分查找中，目标元素的查找区间的定义十分重要，不同的区间的定义写法不一样，大体有两种写法，注意辨析哦</p>\n</div>\n<p><strong>1.左闭右闭 [left , right]</strong><br><strong>2.左闭右开 [left , right]</strong></p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>先看一道leetcode上面的题目<br><a href=\"https://leetcode.cn/problems/binary-search/\">704. 二分查找 - 力扣（Leetcode）</a><br><strong>输入描述</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code></p></blockquote>\n<p><strong>样例1</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>输入:</strong> <code>nums</code> &#x3D; [-1,0,3,5,9,12], <code>target</code> &#x3D; 9<br>  <strong>输出:</strong> 4<br>  <strong>解释:</strong> 9 出现在 <code>nums</code> 中并且下标为 4</p></blockquote>\n<p><strong>样例2</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>输入:</strong> <code>nums</code> &#x3D; [-1,0,3,5,9,12], <code>target</code> &#x3D; 2<br>  <strong>输出:</strong> -1<br>  <strong>解释:</strong> 2 不存在 <code>nums</code> 中因此返回 -1</p></blockquote>\n<p><strong>提示</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>你可以假设 nums 中的所有元素是不重复的。<br>   n 将在 [1, 10000]之间。<br>   nums 的每个元素都将在 [-9999, 9999]之间。</p></blockquote>\n<p><strong>代码(写法1)</strong></p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int search(int nums[], int size, int target)&#123;\n    int left &#x3D; 0;\n    int right &#x3D; size - 1;\n    while (left &lt;&#x3D; right) &#123;\t\n        int middle &#x3D; left + ((right - left) &#x2F; 2);\n        if (nums[middle] &gt; target) \n            right &#x3D; middle - 1;\n\t    else if (nums[middle] &lt; target) \n            left &#x3D; middle + 1;\n        else \n            return middle;\n    &#125;\n    return -1;\n&#125;</code></pre>\n<p><strong>代码(写法2)</strong></p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int search(int nums[], int size, int target)&#123;\n\tint left &#x3D; 0;\n\tint right &#x3D; size;\n\twhile (left &lt; right) &#123;\n\t\tint middle &#x3D; left + ((right - left) &#x2F; 2);\n\t\tif (nums[middle] &gt; target) &#123;\n\t\t\tright &#x3D; middle;\n\t\t&#125; else if (nums[middle] &lt; target) &#123;\n\t\t\tleft &#x3D; middle + 1;\n\t\t&#125; else &#123;\n\t\t\treturn middle;\n\t\t&#125;\n\t&#125; \n\treturn -1;\n&#125;</code></pre>\n<h1 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h1><p>首先定义<code>left</code>和<code>right</code>，确定查找区间，定义<code>middle＝(left+right)/2</code>，判断<code>nums[middle]?=target</code>，若相等，直接<code>return middle</code><br>否则</p>\n<ul>\n<li>如果<code>nums[middle] &gt; target</code>，说明目标数在<code>middle</code>左边，因此下次查找的区间就变成了<code>[left, middle-1]</code>，令<code>right=middle-1</code>，继续查找</li>\n<li>如果<code>nums[middle] &lt; target</code>，说明目标数在<code>middle</code>右边，因此下次查找的区间就变成了<code>[middle+1, right]</code>，令<code>left=middle+1</code>，继续查找</li>\n<li>直到<code>nums[middle]=target</code>或者<code>left&gt;right</code>，结束查找<br>:::tip<br>数组长度为奇数或偶数都不会影响查找，不需要纠结这个问题<br>:::</li>\n</ul>\n<h1 id=\"写法1：左闭右闭-left-right\"><a href=\"#写法1：左闭右闭-left-right\" class=\"headerlink\" title=\"写法1：左闭右闭[left , right]\"></a>写法1：左闭右闭<code>[left , right]</code></h1><ul>\n<li>此时循环条件为<code>left&lt;=right</code>，因为当<code>(left == right)</code>时，结果是有意义的</li>\n<li><code>if(nums[middle] &gt; target)</code> ，<code>right</code>要赋值为<code>middle-1</code>， 这时候<code>nums[middle]!=target</code> ，所以需要把这个<code>middle</code>位置上面的数字丢弃，接下来需要查找的范围是<code>[left, middle - 1]</code>，直到查找结束</li>\n<li>详细过程图解参考上面贴出的原文链接即可，此处不再赘述</li>\n</ul>\n<h1 id=\"写法2：左闭右开-left-right\"><a href=\"#写法2：左闭右开-left-right\" class=\"headerlink\" title=\"写法2：左闭右开 [left , right)\"></a>写法2：左闭右开 <code>[left , right)</code></h1><ul>\n<li>循环条件为<code>left &lt; right</code></li>\n<li><code>if (nums[middle] &gt; target)</code>，<code>right = middle</code>，这时候 <code>nums[middle]&gt;target</code>，不符合条件，不能取到<code>middle</code>，并且区间的定义是<code>[left, right)</code>，刚好区间上的定义就取不到<code>right</code>, 所以<code>right</code>赋值为<code>middle</code>即可，接下来就在<code>[left, middle)</code>上面继续查找即可</li>\n<li>详细过程同样参见原文</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>此方法需为<code>right</code>赋初值为数组长度！因为右边是开区间，并且这种写法只有当<code>nums[middle] &gt; target</code>时和写法一不一样，当<code>nums[middle] &lt; target</code>时，仍然为<code>left=middle+1</code></p>\n</div>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>二分查找是一个很经典的算法，关键在于对循环条件的理解以及各种情况的判断，个人更喜欢第一种写法，相对更容易理解<br><strong>谢谢阅读！(。・ω・。)</strong></p>\n","feature":true,"text":"本文参考了CSDN上的相关文章，原文链接见下(原文写的非常非常好，强烈建议去看看！)【二分查找】详细图解_Charon_cc的博客-CSDN博客-二分查找) 概述要使用二分查找，需要满足：1.要查找的内容在逻辑上是有序的(比如升序、降序)2.只能查找一个元素在满足这两个前提之后，...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"二分查找","slug":"二分查找","count":1,"path":"api/tags/二分查找.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">基本思想</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E6%B3%951%EF%BC%9A%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD-left-right\"><span class=\"toc-text\">写法1：左闭右闭[left , right]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E6%B3%952%EF%BC%9A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80-left-right\"><span class=\"toc-text\">写法2：左闭右开 [left , right)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"寻找数组中和为定值的两个数","uid":"006076f8418c8c0b510fc49a5533190d","slug":"artical2","date":"2023-01-24T06:02:13.787Z","updated":"2023-01-24T07:46:30.123Z","comments":true,"path":"api/articles/artical2.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63cf73cf588a5d166ce0a667.jpg","text":"问题描述输入一个整数数组和一个整数，在数组中查找一对数，满足他们的和正好是输入的那个整数 方法：排序夹逼法（双指针扫描）若原数组无序，考虑先用sort对数组排序，但是如果题目要求输出数组下标，此方法就不太适用了（排序会打乱原数组的下标，输出的时候可能就需要多考虑一些东西了）数组有...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}},"feature":true}}