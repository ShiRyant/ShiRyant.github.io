{"title":"upper_bound与lower_bound的用法","uid":"8cf32e9d14bee8e65785fa5e53e55961","slug":"artical5","date":"2023-01-28T10:51:14.741Z","updated":"2023-01-28T10:59:20.117Z","comments":true,"path":"api/articles/artical5.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63d4fdf5face21e9ef241a52.jpg","content":"<p><strong>在牛客做题的时候偶然了解到的两个函数，发现还挺方便的，这边记录一下</strong><br><strong>原文链接<a href=\"https://blog.csdn.net/qq_40160605/article/details/80150252\">关于lower_bound( )和upper_bound( )的常见用法</a></strong></p>\n<h1 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h1><p><code>#include &lt;algorithm&gt;</code></p>\n<h1 id=\"函数形式及用法\"><a href=\"#函数形式及用法\" class=\"headerlink\" title=\"函数形式及用法\"></a>函数形式及用法</h1><h2 id=\"在从小到大的排序数组中\"><a href=\"#在从小到大的排序数组中\" class=\"headerlink\" title=\"在从小到大的排序数组中\"></a>在从小到大的排序数组中</h2><p><strong><code>lower_bound(begin,end,num)</code></strong><br>从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标<br><strong><code>upper_bound(begin,end,num)</code></strong><br>从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标</p>\n<h2 id=\"在从大到小的排序数组中\"><a href=\"#在从大到小的排序数组中\" class=\"headerlink\" title=\"在从大到小的排序数组中\"></a>在从大到小的排序数组中</h2><p><strong><code>lower_bound(begin,end,num,greater&lt;type&gt;())</code></strong><br>从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标<br><strong><code>upper_bound(begin,end,num,greater&lt;type&gt;())</code></strong><br>从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin，得到找到数字在数组中的下标<br>此外，这两个函数也能通过自定义函数的方式改变查找规则（类似sort()内的cmp）</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>由于 upper_bound() 底层实现采用的是二分查找的方式，因此该函数仅适用于“已排好序”的序列。注意，这里所说的“已排好序”，并不要求数据完全按照某个排序规则进行升序或降序排序，而仅仅要求[first, last) 区域内所有令 element&lt;val（或者 comp(val, element）成立的元素都位于不成立元素的前面</p>\n</div>\n","feature":true,"text":"在牛客做题的时候偶然了解到的两个函数，发现还挺方便的，这边记录一下原文链接关于lower_bound( )和upper_bound( )的常见用法 头文件#include &lt;algorithm&gt; 函数形式及用法在从小到大的排序数组中lower_bound(begin,...","link":"","photos":[],"count_time":{"symbolsCount":864,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":4,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">头文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BD%A2%E5%BC%8F%E5%8F%8A%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">函数形式及用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD\"><span class=\"toc-text\">在从小到大的排序数组中</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD\"><span class=\"toc-text\">在从大到小的排序数组中</span></a></li></ol></li></ol>","author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"前缀和算法","uid":"5ba9516e9c52d7566ec1c7c5d2db970e","slug":"artical4","date":"2023-01-25T05:29:57.240Z","updated":"2023-01-25T05:36:23.316Z","comments":true,"path":"api/articles/artical4.json","keywords":null,"cover":"https://pic.imgdb.cn/item/63d0be2e588a5d166c145d85.jpg","text":"前缀和算法样题题目描述 输入一个长度为n的整数序列 接下来再输入m个询问，每个询问输入一对l, r 对于每个询问，输出原序列中从第l个数到第r个数的和 输入格式 第一行包含两个整数n和m第二行包含n个整数，表示整数数列接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":4,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"}],"author":{"name":"莳雨","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/63ce72fc588a5d166c3aa846.jpg","link":"/","description":"自己搭的一个小博客，可能时不时会往上面发一些内容，谢谢各位的捧场awa~","socials":{"github":"https://github.com/ShiRyant","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/299985456"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/hopeful-payneybf/"}}}},"feature":true}}